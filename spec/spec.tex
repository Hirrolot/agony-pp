\documentclass[12pt]{article}

\usepackage{hyperref}
\usepackage{float}
\usepackage{bussproofs}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{ntheorem}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{tabularx}
\usepackage[english]{babel}

\theoremstyle{break}
\newtheorem{notation}{Notation}

\addbibresource{references.bib}

\floatstyle{boxed}
\restylefloat{figure}

\begin{document}

\title{Macrolop Specification}
\date{\today}
\author{Temirkhan Myrzamadi (a.k.a. Hirrolot)}
\maketitle

\begin{abstract}
This paper is the official specification of Macrolop, a metalanguage aimed at language-oriented
programming in C. In it, both the syntax and reduction semantics are defined formally. See the
official repository \cite{Macrolop} for the user-friendly overview and the official documentation
\cite{MacrolopDocs} for the accompanied standard library.
\end{abstract}

\tableofcontents

\newpage

\section{EBNF Grammar}

\begin{figure}[H]
    \caption{Grammar rules}

\begin{minted}{bnf}
<eval> ::= "MACROLOP_EVAL(" { <term> }* ")" ;

<term> ::= "call(" <op> "," { <term> }* ")"
         | "v(" <preprocessor-token-list> ")" ;

<op>   ::= <ident> | { <term> }+ ;
\end{minted}

\end{figure}

A metaprogram in Macrolop consists of a (possibly empty) sequence of terms, each of which
is either a macro call or just a value.

Notes:

\begin{itemize}
    \item The grammar above describes metaprograms already expanded by the C preprocessor,
    except for \texttt{MACROLOP\_EVAL}, \texttt{call}, and \texttt{v}.
    \item \texttt{call} accepts \texttt{op} either as an identifier or as a non-empty
    sequence of terms that reduces to an identifier.
    \item \texttt{call} accepts arguments without a separator.
\end{itemize}

\section{Reduction Semantics}

We define reduction semantics for Macrolop. The abstract machine executes configurations
of the form $\langle k; acc; control \rangle$:

\begin{itemize}
    \item $k$ is a continuation of the form $\langle k; acc; control \rangle$, where
    $control$ include the $?$ sign, which will be substituted with a result after a
    continuation is called. For example: let $k = \langle k'; (1, 2, 3); v(abc) \ ? \rangle$,
    then $k(v(ghi))$ is $\langle k'; (1, 2, 3); v(abc) \ v(ghi) \rangle$. A special
    continuation $halt$ terminates the abstract machine with provided result.

    \item $acc$ is an accumulator, a sequence \ref{SequencesNotation} of already computed
    results.

    \item $control$ is a concrete sequence of terms upon which the abstract machine is
    operating right now. For example: \texttt{call(FOO, v(123) \\ v(456)) v(w 8) v(blah)}.
\end{itemize}

And here are the computational rules:

\begin{figure}[H]
    \caption{Computational rules}

    \small
    \begin{align*}
        (v): \ & \langle k; acc; v(\overline{tok}) \ t \ \overline{t'} \rangle & \to_1 &
            \langle k; acc, \ \overline{tok}; t \ \overline{t'} \rangle \\
        (v\mbox{-}end): \ & \langle k; acc; v(\overline{tok}) \rangle & \to_1 &
            k(unseq(acc, \overline{tok})) \\
        (op): \ & \langle k; acc; call(\overline{t}, \overline{a}) \ \overline{t'} \rangle & \to_1 &
            \langle \langle k; acc; call(?, \overline{a}) \ \overline{t'} \rangle; (); \overline{t} \rangle \\
        (args): \ & \langle k; acc; call(ident, \overline{a}) \ \overline{t} \rangle & \to_1 &
            \langle \langle k; acc; ident(unseq\mbox{-}cs(?)) \ \overline{t} \rangle; (); \overline{a} \rangle \\
        (start): \ & MACROLOP\_EVAL(\overline{t}) & \to_1 &
            \langle halt; (); \overline{t} \rangle
    \end{align*}
    \normalsize
\end{figure}

\label{SequencesNotation}
\begin{notation}[Sequences]
    \begin{enumerate}
        \item A sequence has the form $(x_1, \ldots, x_n)$.
        \item $()$ denotes the empty sequence.
        \item An element can be appended by comma: if $a = (1, 2, 3)$ and $b = 4$, then $a, b = (1, 2, 3, 4)$.
        \item \texttt{unseq} extracts elements from a sequence without a separator:
        \texttt{unseq( \\ (a, b, c)) = a b c}.
        \item \texttt{unseq-cs} extracts elements from a sequence separated by comma: \\
        \texttt{unseq-cs((a, b, c)) = a, b, c}.
    \end{enumerate}
\end{notation}

\begin{notation}[Reduction step]
    $\to_1$ denotes a single step of reduction (computation).
\end{notation}

\begin{notation}[Concrete sequence]
    $\overline{x}$ denotes a concrete sequence $x_1 \ldots x_n$. For example:
    \texttt{v(abc) call(FOO, v(123)) v(u 8 9)}.
\end{notation}

\begin{notation}[Meta-variables]
    \ \\
    \begin{tabular}{|c|c|}
        \hline
        \texttt{tok} & C preprocessor token \\
        \texttt{ident} & C preprocessor identifier \\
        \texttt{t} & Macrolop term \\
        \texttt{a} & Macrolop term used as an argument \\
        \hline
    \end{tabular}
\end{notation}

Notes:

\begin{itemize}
    \item A body of a macro called using \texttt{call} must follow the grammar of
    Macrolop, otherwise it might result in a compilation error.
    \item With the current implementation, at most $2^{14}$ reduction steps is
    possible. After exceeding this limit, compilation will likely fail.
\end{itemize}

\printbibliography

\end{document}
