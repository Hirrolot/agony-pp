\documentclass[a4paper, 12pt]{article}

\usepackage{hyperref}
\usepackage{float}
\usepackage{bussproofs}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{ntheorem}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage[english]{babel}

\theoremstyle{break}
\newtheorem{notation}{Notation}

\addbibresource{references.bib}

\geometry{margin=60px}
\floatstyle{boxed}
\restylefloat{figure}

\begin{document}

\title{Macrolop Specification}
\date{\today}
\author{Temirkhan Myrzamadi (a.k.a. Hirrolot)}
\maketitle

\abstract{
Macrolop \cite{Macrolop} is a metalanguage on top of the standard C preprocessor aimed at
language-oriented programming. The idea is to express intention in terms of domain-specific
languages, providing a way to extend C with new programming language constructs, leading to
a clearer and safer design of APIs. One example is typext4c \cite{typext4c}, a header-only
library implementing various type system extensions for pure C.

The two main characteristics of this projects are:

\begin{itemize}
    \item \textbf{Embedded.} Macrolop is implemented as a set of standard-compliant C99 macros,
    therefore it can be embedded directly in \texttt{*.c}/\texttt{*.h} source files without
    introducing third-party code generators.

    \item \textbf{General recursion.} The recursion mechanism is explicitly blocked by the
    standard \cite{IsC99TuringComplete}. Contrary to Boost/Preprocessor \cite{BoostPreprocessor},
    Macrolop provides general recursion as-is (up to a certain limit, see
    \ref{ReductionSemantics}).
\end{itemize}

This document describes the formal syntax and semantics of the metalanguage. See
the official documentation \cite{MacrolopDocs} for the accompanied standard library.
}

\tableofcontents

\newpage

\section{EBNF Grammar}

\begin{figure}[H]
    \caption{Grammar rules}

\begin{minted}{bnf}
<eval> ::= "MACROLOP_EVAL(" { <term> }* ")" ;

<term> ::= "call(" <op> "," { <term> }* ")"
         | "v(" <preprocessor-token-list> ")" ;

<op>   ::= <ident> | { <term> }+ ;
\end{minted}

\end{figure}

A metaprogram in Macrolop consists of a (possibly empty) sequence of terms, each of which
is either a macro call or just a value.

Notes:

\begin{itemize}
    \item The grammar above describes metaprograms already expanded by the C preprocessor,
    except for \texttt{MACROLOP\_EVAL}, \texttt{call}, and \texttt{v}.
    \item \texttt{call} accepts \texttt{op} either as an identifier or as a non-empty
    sequence of terms that reduces to an identifier.
    \item \texttt{call} accepts arguments without a separator.
\end{itemize}

\section{Notations}

\begin{notation}[Sequences]
    \begin{enumerate}
        \item A sequence has the form $(x_1, \ldots, x_n)$.
        \item $()$ denotes the empty sequence.
        \item An element can be appended by comma: if $a = (1, 2, 3)$ and $b = 4$, then $a, b = (1, 2, 3, 4)$.
        \item \texttt{seq-extract} extracts elements from a sequence without a separator:
        \texttt{seq-extract((a, b, c)) = a \ b \ c}.
        \item \texttt{seq-comma-sep} extracts elements from a sequence separated by comma: \\
        \texttt{seq-comma-sep((a, b, c)) = a, b, c}.
    \end{enumerate}
\end{notation}

\section{Reduction Semantics}
\label{ReductionSemantics}

We define reduction semantics for Macrolop. The abstract machine executes configurations
of the form $\langle k; acc; control \rangle$:

\begin{itemize}
    \item $k$ is a continuation of the form $\langle k; acc; control \rangle$, where
    $control$ include the $?$ sign, which will be substituted with a result after a
    continuation is called. For example: let $k = \langle k'; (1, 2, 3); v(abc) \ ? \rangle$,
    then $k(v(ghi))$ is $\langle k'; (1, 2, 3); v(abc) \ v(ghi) \rangle$. A special
    continuation $halt$ terminates the abstract machine with provided result.

    \item $acc$ is an accumulator, a sequence of already computed results.

    \item $control$ is a concrete sequence of terms upon which the abstract machine is
    operating right now. For example: \texttt{call(FOO, v(123) v(456)) v(w 8) v(blah)}.
\end{itemize}

And here are the computational rules:

\begin{figure}[H]
    \caption{Computational rules}

    \begin{align*}
        (v): \ & \langle k; acc; v(\overline{tok}) \ term \ \overline{term'} \rangle & \to_1 &
            \langle k; acc, \ \overline{tok}; term \ \overline{term'} \rangle \\
        (v\mbox{-}end): \ & \langle k; acc; v(\overline{tok}) \rangle & \to_1 &
            k(seq\mbox{-}extract(acc, \overline{tok})) \\
        (op): \ & \langle k; acc; call(\overline{term}, \overline{a}) \ \overline{term'} \rangle & \to_1 &
            \langle \langle k; acc; call(?, \overline{a}) \ \overline{term'} \rangle; (); \overline{term} \rangle \\
        (args): \ & \langle k; acc; call(ident, \overline{a}) \ \overline{term} \rangle & \to_1 &
            \langle \langle k; acc; ident(seq\mbox{-}comma\mbox{-}sep(?)) \ \overline{term} \rangle; (); \overline{a} \rangle \\
        (start): \ & MACROLOP\_EVAL(\overline{term}) & \to_1 &
            \langle halt; (); \overline{term} \rangle \\
    \end{align*}
\end{figure}

\begin{notation}[Reduction step; concrete sequence; meta-variables]
    \begin{enumerate}
        \item $\to_1$ denotes a single step of reduction (computation).

        \item $\overline{x}$ denotes a concrete sequence $x_1 \ldots x_n$. For example:
        \texttt{v(abc) call(FOO, v(123)) v(u 8 9)}.

        \item \texttt{tok} denotes a single C preprocessor token, \texttt{term} is a term defined
    by the grammar, \texttt{a} is a term used as an argument.
    \end{enumerate}
\end{notation}

Notes:

\begin{itemize}
    \item A body of a macro called using \texttt{call} must follow the grammar of
    Macrolop, otherwise it might result in a compilation error.
    \item With the current implementation, at most $2^{14}$ reduction steps is
    possible. After exceeding this limit, compilation will likely fail.
\end{itemize}

\printbibliography

\end{document}
